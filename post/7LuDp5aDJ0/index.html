<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Meowstic小屋</title>
<meta name="description" content="人心各有所感，最是没道理可讲。" />
<link rel="shortcut icon" href="https://nekou2333.github.io/favicon.ico?v=1756312012811">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css">

<link rel="stylesheet" href="https://nekou2333.github.io/styles/main.css">



  </head>
  <body>
    <div id="app" class="main px-4 flex flex-col lg:flex-row">
      <div id="sidebar" class="sidebar-wrapper lg:static lg:w-1/4">
  <div class="lg:sticky top-0">
    <div class="sidebar-content">
      <div class="flex lg:block p-4 lg:px-0 items-center fixed lg:static lg:block top-0 right-0 left-0 bg-white z-50">
        <i class="ri-menu-2-line lg:mt-4 text-2xl cursor-pointer animated fadeIn" onclick="openMenu()"></i>
        <a href="https://nekou2333.github.io">
          <img class="animated fadeInLeft avatar rounded-lg mx-4 lg:mt-32 lg:mx-0 mt-0 lg:w-24 lg:h-24 w-12 w-12" src="https://nekou2333.github.io/images/avatar.png?v=1756312012811" alt="">
        </a>
        <h1 class="animated fadeInLeft lg:text-4xl font-extrabold lg:mt-8 mt-0 text-xl" style="animation-delay: 0.2s">Meowstic小屋</h1>
      </div>
      
        <div class="animated fadeInLeft" style="animation-delay: 0.4s">
          <p class="my-4 text-gray-600 font-light hidden lg:block">
            文章目录
          </p>
          <div class="toc-container hidden lg:block">
            <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#the-second-half">The Second Half</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      
    </div>
  </div>
</div>

<div class="menu-container">
  <i class="ri-arrow-left-line text-2xl cursor-pointer animated fadeIn close-menu-btn" onclick="closeMenu()"></i>
  <div>
    
      
        <a href="/" class="menu" style="animation-delay: 0s">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu" style="animation-delay: 0.2s">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu" style="animation-delay: 0.4s">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu" style="animation-delay: 0.6000000000000001s">
          关于
        </a>
      
    
      
        <a href="/blogs" class="menu" style="animation-delay: 0.8s">
          新博客
        </a>
      
    
  </div>
  <div class="site-footer">
    <div class="py-4 text-gray-700">Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a></div>
    <a class="rss" href="https://nekou2333.github.io/atom.xml" target="_blank">RSS</a>
  </div>
</div>
<div class="mask" onclick="closeMenu()">
</div>
      <div class="content-wrapper py-32 lg:p-8 lg:w-3/4 post-detail animated fadeIn">
        <h1 class="text-3xl font-bold lg:mt-16">「翻译」The Second Half</h1>
        <div class="text-sm text-gray-700 lg:my-8">
          2025-08-19 / 10 min read
        </div>
        
        <div class="post-content yue">
          <p>原文：https://ysymyth.github.io/The-Second-Half/</p>
<h2 id="the-second-half">The Second Half</h2>
<blockquote>
<p>This recipe is completely changing the game. To recap the game of the first half:</p>
<ul>
<li>We develop novel training methods or models that hillclimb benchmarks.</li>
<li>We create harder benchmarks and continue the loop.</li>
</ul>
<p>This game is being ruined because:</p>
<ul>
<li>The recipe has essentially standardized and industried benchmark hillclimbing without requiring much more new ideas. As the recipe scales and generalizes well, your novel method for a particular task might improve it by 5%, while the next o-series model improve it by 30% without explicitly targeting it.</li>
<li>Even if we create harder benchmarks, pretty soon (and increasingly soon) they get solved by the recipe. My colleague Jason Wei made a beautiful figure to visualize the trend well:</li>
</ul>
</blockquote>
<p>这个方法正在彻底改变游戏规则。回顾一下上半场的游戏：</p>
<ul>
<li>我们开发新颖的训练方法或模型来逐步提升基准测试的性能。</li>
<li>我们创建更难的基准测试，然后继续这个循环。</li>
</ul>
<p>这个游戏之所以正在被破坏，原因如下：</p>
<ul>
<li>该方法本质上已经将基准测试的性能提升过程标准化和工业化，不再需要太多新的想法。由于这种方法具有良好的扩展性和泛化性，你针对特定任务提出的新颖方法可能只能将性能提升5%，而下一个o系列模型在没有明确针对该任务的情况下就能将其提升30%。</li>
<li>即使我们创建更难的基准测试，很快（而且越来越快）它们也会被这种方法解决。我的同事杰森·魏（Jason Wei）制作了一张精美的图表，很好地可视化了这一趋势：</li>
</ul>
<p>![[Pasted image 20250819190444.png]]</p>
<blockquote>
<p>Then what’s left to play in the second half? If novel methods are no longer needed and harder benchmarks will just get solved increasingly soon, what should we do?</p>
</blockquote>
<p>那么下半场还有什么可玩的呢？如果不再需要新颖的方法，更难的基准测试也会很快被解决，我们该怎么办？</p>
<blockquote>
<p>I think we should fundamentally re-think evaluation. It means not just to create new and harder benchmarks, but to fundamentally question existing evaluation setups and create new ones, so that we are forced to invent new methods beyond the working recipe. It is hard because humans have inertia and seldom question basic assumptions - you just take them for granted without realizing they are assumptions, not laws.</p>
</blockquote>
<p>我认为我们应该从根本上重新思考评估。这意味着不仅仅是创建新的、更难的基准测试，而是从根本上质疑现有的评估设置并创建新的评估设置，这样我们就不得不发明超越现有有效方法的新方法。这很难，因为人类有惯性，很少质疑基本假设——你只是想当然地接受它们，却没有意识到它们是假设，而不是定律。</p>
<blockquote>
<p>To explain inertia, suppose you invented one of the most successful evals in history based on human exams. It was an extremely bold idea in 2021, but 3 years later it’s saturated. What would you do? Most likely create a much harder exam. Or suppose you solved simply coding tasks. What would you do? Most likely find harder coding tasks to solve until you have reached IOI gold level.</p>
</blockquote>
<p>为了解释惯性，假设你发明了历史上最成功的基于人类考试的评估之一。在2021年，这是一个极其大胆的想法，但3年后它就饱和了。你会怎么做？最有可能的是创建一个更难的考试。或者假设你解决了简单的编码任务。你会怎么做？最有可能的是找到更难的编码任务去解决，直到达到IOI金牌水平。</p>
<blockquote>
<p>Inertia is natural, but here is the problem. AI has beat world champions at chess and Go, surpassed most humans on SAT and bar exams, and reached gold medal level on IOI and IMO. But the world hasn’t changed much, at least judged by economics and GDP.</p>
</blockquote>
<p>惯性是自然的，但问题就在这里。人工智能已经击败了国际象棋和围棋的世界冠军，在SAT和律师资格考试中超过了大多数人类，在IOI和IMO中达到了金牌水平。但世界并没有发生太大变化，至少从经济和GDP来看是这样。</p>
<blockquote>
<p>I call this the utility problem, and deem it the most important problem for AI.</p>
<p>Perhaps we will solve the utility problem pretty soon, perhaps not. Either way, the root cause of this problem might be deceptively simple: our evaluation setups are different from real-world setups in many basic ways. To name two examples:</p>
</blockquote>
<p>我将此称为效用问题，并认为它是人工智能最重要的问题。</p>
<p>也许我们很快就能解决效用问题，也许不能。无论如何，这个问题的根本原因可能简单得令人难以置信：我们的评估设置在许多基本方面与现实世界的设置不同。举两个例子：</p>
<blockquote>
<ul>
<li>Evaluation “should” run automatically, so typically an agent receives a task input, do things autonomously, then receive a task reward. But in reality, an agent has to engage with a human throughout the task — you don’t just text customer service a super long message, wait for 10 minutes, then expect a detailed response to settle everything. By questioning this setup, new benchmarks are invented to either engage real humans (e.g. Chatbot Arena) or user simulation (e.g. tau-bench) in the loop.</li>
</ul>
</blockquote>
<ul>
<li>评估“应当”是自动化运行的，因此通常智能体接收任务输入后会自主行动，然后获得任务奖励。但实际上，智能体在整个任务过程中都必须与人类互动——你不会只给客服发一条超长消息，等10分钟就指望得到详细回复并解决所有问题。通过对这种设置提出质疑，新的基准测试被开发出来，将真实人类（例如Chatbot Arena）或用户模拟（例如tau-bench）纳入循环。</li>
</ul>
<blockquote>
<ul>
<li>Evaluation “should” run i.i.d. If you have a test set with 500 tasks, you run each task independently, average the task metrics, and get an overall metric. But in reality, you solve tasks sequentially rather than in parallel. A Google SWE solves google3 issues increasingly better as she gets more familiar with the repo, but a SWE agent solves many issues in the same repo without gaining such familiarity. We obviously need long-term memory methods (and there are), but academia does not have the proper benchmarks to justify the need, or even the proper courage to question i.i.d. assumption that has been the foundation of machine learning.</li>
</ul>
</blockquote>
<ul>
<li>评估“应当”满足独立同分布（i.i.d.）。如果你有一个包含500个任务的测试集，你会独立运行每个任务，取任务指标的平均值，从而得到整体指标。但现实中，你是按顺序而非并行地解决任务。一名谷歌软件工程师（SWE）会随着对代码库的熟悉程度提高，越来越出色地解决google3的问题，而一个软件工程师智能体在处理同一个代码库中的多个问题时却不会获得这种熟悉度。显然，我们需要长期记忆方法（而且确实存在一些），但学术界缺乏恰当的基准测试来证明这种需求的合理性，甚至缺乏质疑独立同分布这一机器学习基础假设的勇气。</li>
</ul>
<blockquote>
<p>These assumptions have “always” been like this, and developing benchmarks in these assumptions were fine in the first half of AI, because when the intelligence is low, improving intelligence generally improves utility. But now, the general recipe is guaranteed to work under these assumptions. So the way to play the new game of the second half is</p>
</blockquote>
<p>这些假设“一直以来”都是如此，在人工智能的前半场，基于这些假设开发基准测试是可行的，因为当智能水平较低时，提高智能通常会提升效用。但现在，在这些假设下，通用方法已被证明是有效的。因此，人工智能下半场的新玩法是：</p>
<blockquote>
<p>We develop novel evaluation setups or tasks for real-world utility.<br>
We solve them with the recipe or augment the recipe with novel components. Continue the loop.</p>
</blockquote>
<p>我们为现实世界的效用开发新颖的评估设置或任务。<br>
我们使用通用方法来解决这些问题，或者用新颖的组件增强通用方法。如此循环往复。</p>
<blockquote>
<p>This game is hard because it is unfamiliar. But it is exciting. While players in the first half solve video games and exams, players in the second half get to build billion or trillion dollar companies by building useful products out of intelligence. While the first half is filled with incremental methods and models, the second half filters them to some degree. The general recipe would just crush your incremental methods, unless you create new assumptions that break the recipe. Then you get to do truly game-changing research.</p>
</blockquote>
<p>这个游戏之所以困难，是因为它陌生。但它也令人兴奋。如果说上半场的参与者在解决电子游戏和考试问题，那么下半场的参与者则通过将智能转化为有用的产品，打造价值数十亿甚至数万亿美元的公司。如果说上半场充斥着增量式的方法和模型，那么下半场在某种程度上会对它们进行筛选。通用方法会轻松碾压你的增量式方法，除非你创造新的假设来打破这种通用方法。那样，你就能开展真正具有颠覆性的研究。</p>
<p>欢迎来到下半场！</p>

        </div>

        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://nekou2333.github.io/tag/6yptC3jVd_/">
            <span class="flex-auto">翻译</span>
          </a>
        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://nekou2333.github.io/tag/XHXwxapTp/">
            <span class="flex-auto">LLM</span>
          </a>
        


        <div class="flex justify-between py-8">
          

          
            <div class="next-post">
              <a href="https://nekou2333.github.io/post/ZDB0yM7S4l/">
                <h3 class="post-title">
                  「翻译」Waterfowl and ABCs
                  <i class="ri-arrow-right-line"></i>
                </h3>
              </a>
            </div>
          
        </div>

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '70c8e2607aa83cbddbd7',
    clientSecret: 'e1881f080e2c1300070a8e2817206d99dc9cfcd9',
    repo: 'nekou2333/BlogComments',
    owner: 'nekou2333',
    admin: ['nekou2333'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

      </div>
    </div>

    <script src="https://nekou2333.github.io/media/prism.js"></script>  
<script>

Prism.highlightAll()
let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

// This should probably be throttled.
// Especially because it triggers during smooth scrolling.
// https://lodash.com/docs/4.17.10#throttle
// You could do like...
// window.addEventListener("scroll", () => {
//    _.throttle(doThatStuff, 100);
// });
// Only not doing it here to keep this Pen dependency-free.

window.addEventListener("scroll", event => {
  let fromTop = window.scrollY;

  mainNavLinks.forEach((link, index) => {
    let section = document.getElementById(decodeURI(link.hash).substring(1));
    let nextSection = null
    if (mainNavLinks[index + 1]) {
      nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
    }
    if (section.offsetTop <= fromTop) {
      if (nextSection) {
        if (nextSection.offsetTop > fromTop) {
          link.classList.add("current");
        } else {
          link.classList.remove("current");    
        }
      } else {
        link.classList.add("current");
      }
    } else {
      link.classList.remove("current");
    }
  });
});


document.addEventListener("DOMContentLoaded", function() {
  var lazyImages = [].slice.call(document.querySelectorAll(".post-feature-image.lazy"));

  if ("IntersectionObserver" in window) {
    let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          let lazyImage = entry.target
          lazyImage.style.backgroundImage = `url(${lazyImage.dataset.bg})`
          lazyImage.classList.remove("lazy")
          lazyImageObserver.unobserve(lazyImage)
        }
      });
    });

    lazyImages.forEach(function(lazyImage) {
      lazyImageObserver.observe(lazyImage)
    })
  } else {
    // Possibly fall back to a more compatible method here
  }
});

const menuContainer = document.querySelector('.menu-container')
const menus = document.querySelectorAll('.menu-container .menu')
const mask = document.querySelector('.mask')
const contentWrapper = document.querySelector('.content-wrapper')
const latestArticle = document.querySelector('.latest-article')
const readMore = document.querySelector('.read-more')
const indexPage = document.querySelector('.index-page')

const isHome = location.pathname === '/'
if (latestArticle) {
  latestArticle.style.display = isHome ? 'block' : 'none'
  readMore.style.display = isHome ? 'block' : 'none'
  indexPage.style.display = isHome ? 'none' : 'block'
}

const openMenu = () => {
  menuContainer.classList.add('open')
  menus.forEach(menu => {
    menu.classList.add('animated', 'fadeInLeft')
  })
  mask.classList.add('open')
  contentWrapper.classList.add('is-second')
}

const closeMenu = () => {
  menuContainer.classList.remove('open')
  menus.forEach(menu => {
    menu.classList.remove('animated', 'fadeInLeft')
  })
  mask.classList.remove('open')
  contentWrapper.classList.remove('is-second')
}
</script>
  
  </body>
</html>
